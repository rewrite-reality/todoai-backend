// ============================================================================
// Todo AI - Production-Ready Prisma Schema
// Version: 3.0.0 (Task Assignees + Invites + Shared Projects)
// Architecture: AI-First Task Manager with Telegram Integration
// ============================================================================

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearch", "postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  extensions = [pgcrypto]
}

// ============================================================================
// ENUMS
// ============================================================================

enum TaskStatus {
  BACKLOG
  TODO
  IN_PROGRESS
  BLOCKED
  DONE
  ARCHIVED
  PARSE_FAILED
}

enum TaskPriority {
  NONE
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum InputType {
  TEXT
  VOICE
}

enum ChatRole {
  USER
  ASSISTANT
  SYSTEM
}

enum ActionType {
  CREATE
  UPDATE
  DELETE
  RESTORE
  AI_MUTATION
  REORDER
}

enum EntityType {
  PROJECT
  TASK
  SUBTASK
  CHAT_MESSAGE
  TASK_ASSIGNEE
}

enum SubscriptionTier {
  FREE
  PRO
  TEAM
}

// NEW: Task assignment lifecycle
enum AssigneeStatus {
  PENDING
  CONNECTED
  DECLINED
  REVOKED
}

// NEW: Invite lifecycle
enum InviteStatus {
  PENDING
  ACCEPTED
  EXPIRED
  REVOKED
}

// NEW: Invite scope (extensible for future features)
enum InviteScope {
  USER_ONLY
  PROJECT_INVITE
}

// NEW: Project membership roles
enum ProjectRole {
  OWNER
  ADMIN
  MEMBER
  VIEWER
}

// ============================================================================
// MODELS
// ============================================================================

model User {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  telegramId    BigInt  @unique @map("telegram_id")
  telegramName  String? @map("telegram_name") @db.VarChar(255)
  telegramPhoto String? @map("telegram_photo") @db.VarChar(512)

  encryptedApiKey String? @map("encrypted_api_key") @db.Text

  tier             SubscriptionTier @default(FREE)
  aiCreditsUsed    Int              @default(0) @map("ai_credits_used")
  aiCreditsResetAt DateTime?        @map("ai_credits_reset_at")

  timezone    String  @default("UTC") @db.VarChar(50)
  locale      String  @default("en") @db.VarChar(10)
  isOnboarded Boolean @default(false) @map("is_onboarded")

  deletedAt DateTime? @map("deleted_at")

  // Relations — owned entities
  projects      Project[]
  tasks         Task[]

  // Relations — action history
  actionHistory ActionHistory[] @relation("ActionAuthor")
  undoneActions ActionHistory[] @relation("ActionUndoneBy")

  // NEW: Task assignments where this user IS the assignee
  assignedTasks TaskAssignee[] @relation("Assignee")

  // NEW: Task assignments created BY this user
  assignedByMe TaskAssignee[] @relation("AssignedBy")

  // NEW: Invites created by this user
  createdInvites Invite[] @relation("InviteCreator")

  // NEW: Project memberships
  projectMemberships ProjectMember[] @relation("MemberUser")

  // NEW: Project memberships where this user invited someone
  invitedMembers ProjectMember[] @relation("MemberInvitedBy")

  @@index([telegramId])
  @@index([deletedAt])
  @@map("users")
}

model Project {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  name        String  @db.VarChar(255)
  description String? @db.Text
  emoji       String? @db.VarChar(10)
  color       String? @db.VarChar(7)

  aiContext String? @map("ai_context") @db.Text
  order     Int     @default(0)

  parentId String?   @map("parent_id") @db.Uuid
  parent   Project?  @relation("ProjectHierarchy", fields: [parentId], references: [id], onDelete: SetNull)
  children Project[] @relation("ProjectHierarchy")

  isArchived Boolean   @default(false) @map("is_archived")
  deletedAt  DateTime? @map("deleted_at")

  userId String @map("user_id") @db.Uuid
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  tasks Task[]

  // NEW: Project members (shared access)
  members ProjectMember[]

  // NEW: Invites scoped to this project
  invites Invite[]

  @@index([userId, deletedAt])
  @@index([userId, order])
  @@map("projects")
}

model Task {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  title   String  @db.VarChar(500)
  summary String? @db.Text

  originalInput     String?    @map("original_input") @db.Text
  originalInputType InputType? @map("original_input_type")

  status   TaskStatus   @default(TODO)
  priority TaskPriority @default(NONE)

  deadline         DateTime?
  startDate        DateTime? @map("start_date")
  estimatedMinutes Int?      @map("estimated_minutes")
  order            Int       @default(0)

  aiProcessedAt DateTime? @map("ai_processed_at")
  aiModelUsed   String?   @map("ai_model_used") @db.VarChar(50)
  aiTokensUsed  Int?      @map("ai_tokens_used")

  deletedAt DateTime? @map("deleted_at")

  userId String @map("user_id") @db.Uuid
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  projectId String?  @map("project_id") @db.Uuid
  project   Project? @relation(fields: [projectId], references: [id], onDelete: SetNull)

  subtasks     Subtask[]
  chatMessages ChatMessage[]

  // NEW: Task-level assignees (0..N)
  assignees TaskAssignee[]

  @@index([userId, deletedAt])
  @@index([userId, status, deletedAt])
  @@index([userId, deadline, deletedAt])
  @@index([projectId, order])
  @@map("tasks")
}

model Subtask {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  title       String    @db.VarChar(500)
  isCompleted Boolean   @default(false) @map("is_completed")
  completedAt DateTime? @map("completed_at")
  order       Int       @default(0)

  isAiGenerated Boolean   @default(false) @map("is_ai_generated")
  deletedAt     DateTime? @map("deleted_at")

  taskId String @map("task_id") @db.Uuid
  task   Task   @relation(fields: [taskId], references: [id], onDelete: Cascade)

  @@index([taskId, deletedAt, order])
  @@map("subtasks")
}

model ChatMessage {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")

  role       ChatRole
  content    String  @db.Text
  isExcluded Boolean @default(false) @map("is_excluded")

  aiModelUsed  String? @map("ai_model_used") @db.VarChar(50)
  aiTokensUsed Int?    @map("ai_tokens_used")

  appliedAt  DateTime?      @map("applied_at")
  mutationId String?        @map("mutation_id") @db.Uuid
  mutation   ActionHistory? @relation(fields: [mutationId], references: [id], onDelete: SetNull)

  deletedAt DateTime? @map("deleted_at")

  taskId String @map("task_id") @db.Uuid
  task   Task   @relation(fields: [taskId], references: [id], onDelete: Cascade)

  @@index([taskId, deletedAt, createdAt])
  @@index([taskId, isExcluded])
  @@index([mutationId])
  @@map("chat_messages")
}

model ActionHistory {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")

  userId String @map("user_id") @db.Uuid
  user   User   @relation("ActionAuthor", fields: [userId], references: [id], onDelete: Cascade)

  actionType ActionType @map("action_type")
  entityType EntityType @map("entity_type")
  entityId   String     @map("entity_id") @db.Uuid

  payload Json @db.JsonB

  aiPromptUsed String? @map("ai_prompt_used") @db.Text
  aiModelUsed  String? @map("ai_model_used") @db.VarChar(50)
  aiTokensUsed Int?    @map("ai_tokens_used")

  isUndone   Boolean   @default(false) @map("is_undone")
  undoneAt   DateTime? @map("undone_at")
  undoneById String?   @map("undone_by_id") @db.Uuid
  undoneBy   User?     @relation("ActionUndoneBy", fields: [undoneById], references: [id], onDelete: SetNull)

  chatMessages ChatMessage[]

  @@index([userId, createdAt(sort: Desc)])
  @@index([entityType, entityId, createdAt(sort: Desc)])
  @@index([isUndone, createdAt(sort: Desc)])
  @@map("action_history")
}

// ============================================================================
// NEW MODELS: Task Assignment, Invite, Project Membership
// ============================================================================

/// Назначение исполнителя на задачу.
/// Lifecycle: PENDING (soft assign by @username) → CONNECTED (user arrived via deep-link)
///            or → DECLINED / REVOKED
model TaskAssignee {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Which task this assignment belongs to
  taskId String @map("task_id") @db.Uuid
  task   Task   @relation(fields: [taskId], references: [id], onDelete: Cascade)

  // Who created the assignment
  assignedByUserId String @map("assigned_by_user_id") @db.Uuid
  assignedBy       User   @relation("AssignedBy", fields: [assignedByUserId], references: [id], onDelete: Cascade)

  // Assignment status
  status AssigneeStatus @default(PENDING)

  // The Telegram @username used for soft-assign (stored lowercase, without @)
  // Required for PENDING; kept as historical record after CONNECTED
  telegramUsername String? @map("telegram_username") @db.VarChar(255)

  // Resolved user — filled when assignee arrives via deep-link
  assigneeUserId String? @map("assignee_user_id") @db.Uuid
  assignee       User?   @relation("Assignee", fields: [assigneeUserId], references: [id], onDelete: SetNull)

  // Timestamps
  invitedAt   DateTime  @default(now()) @map("invited_at")
  connectedAt DateTime? @map("connected_at")
  revokedAt   DateTime? @map("revoked_at")
  declinedAt  DateTime? @map("declined_at")

  // Optional note from assigner
  note String? @db.Text

  // Soft delete
  deletedAt DateTime? @map("deleted_at")

  // --- Indexes ---
  // "Tasks assigned TO me" (after connect)
  @@index([assigneeUserId, deletedAt])
  // "All pending assignments for a given username" (for connect resolution)
  @@index([telegramUsername, status, deletedAt])
  // "Assignees of a task"
  @@index([taskId, deletedAt])
  // "Assignments created by user"
  @@index([assignedByUserId, deletedAt])
  @@map("task_assignees")
}

/// Invite token for connecting an unregistered Telegram user.
/// Created via /connect_user command. Consumed when target user taps deep-link.
model Invite {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Cryptographically random token used in deep-link: t.me/bot?start=invite_{token}
  token String @unique @db.VarChar(128)

  // Who created the invite
  createdByUserId String @map("created_by_user_id") @db.Uuid
  createdBy       User   @relation("InviteCreator", fields: [createdByUserId], references: [id], onDelete: Cascade)

  // Target identification
  targetTelegramUsername String  @map("target_telegram_username") @db.VarChar(255)
  targetTelegramId       BigInt? @map("target_telegram_id")

  // Lifecycle
  status    InviteStatus @default(PENDING)
  expiresAt DateTime     @map("expires_at")
  usedAt    DateTime?    @map("used_at")
  revokedAt DateTime?    @map("revoked_at")

  // Scope: USER_ONLY now, PROJECT_INVITE in the future
  scope InviteScope @default(USER_ONLY)

  // Optional project binding (for future PROJECT_INVITE scope)
  projectId String?  @map("project_id") @db.Uuid
  project   Project? @relation(fields: [projectId], references: [id], onDelete: SetNull)

  // Metadata — can store { taskAssigneeId } to auto-link on acceptance
  metadata Json? @db.JsonB

  // --- Indexes ---
  // token is already @unique, so implicit unique index
  // Lookup pending invites by target username
  @@index([targetTelegramUsername, status])
  // Cleanup expired invites
  @@index([expiresAt, status])
  // Invites created by user
  @@index([createdByUserId])
  @@map("invites")
}

/// Project membership for future shared/collaborative projects.
/// Minimal model — no full ACL yet, just role-based membership.
model ProjectMember {
  id        String   @id @default(uuid()) @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  projectId String  @map("project_id") @db.Uuid
  project   Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  userId String @map("user_id") @db.Uuid
  user   User   @relation("MemberUser", fields: [userId], references: [id], onDelete: Cascade)

  role ProjectRole @default(MEMBER)

  // Who invited this member (null for the original OWNER)
  invitedByUserId String? @map("invited_by_user_id") @db.Uuid
  invitedBy       User?   @relation("MemberInvitedBy", fields: [invitedByUserId], references: [id], onDelete: SetNull)

  joinedAt DateTime @default(now()) @map("joined_at")

  // Soft delete
  deletedAt DateTime? @map("deleted_at")

  // --- Indexes ---
  // "My projects" — fast lookup
  @@index([userId, deletedAt])
  // "Members of a project"
  @@index([projectId, deletedAt])
  @@map("project_members")
}
